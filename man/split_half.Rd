% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MH_SHR.R
\name{split_half}
\alias{split_half}
\title{Split half reliability (SHR)}
\usage{
split_half(
  X,
  Y,
  ttmethod,
  n_iter = 99,
  rand_type = "rand_rows",
  tol = .Machine$double.eps,
  n_splits = 100
)
}
\arguments{
\item{X}{first data matrix}

\item{Y}{second data matrix}

\item{ttmethod}{string denoting the two-table method to use,
either 'plsc', 'cca', or 'rda'.}

\item{n_iter}{(default: 99) number of permutation iterations}

\item{rand_type}{(default: 'rand_rows') how to randomize the matrices,
either 'rand_rows'/'RR' or 'rand_each_col'/'REC'.
The RR option permutes entire rows of the \code{X} matrix while leaving \code{Y} unchanged.
The REC option permutes every column of both \code{X} and \code{Y}.}

\item{tol}{(default: \code{.Machine$double.eps}) tolerance value for eigenvalues}

\item{n_splits}{(default: 100) number of data splits used to compute the \code{Pcorr_mean} and \code{Qcorr_mean}.}
}
\value{
a list containing:
\itemize{
\item \code{fixed_res}: a list containing results from the original, unpermuted analysis.
\itemize{
\item \code{d}: singular values
\item \code{u}: left singular vectors
\item \code{v}: right singular vectors
\item \code{f}: loadings for \code{X}
\item \code{g}: loadings for \code{Y}
}
\item \code{perm_res}: a list containing results from the permutation iterations.
\itemize{
\item \code{Pcorr_mean}: a vector containing the mean of the \code{Pcorr} values for each component.
\item \code{Pcorr_mean_dist}: a matrix of size \code{n_iter + 1} by \code{length(Pcorr_mean)} containing the
null distributions of the Pcorr values
\item \code{Qcorr_mean}: a vector containing the mean of the \code{Qcorr} values for each component.
\item \code{Qcorr_mean_dist}: a matrix of size \code{n_iter + 1} by \code{length(Qcorr_mean)} containing the
null distributions of the Qcorr values
}
}
}
\description{
SHR is a two-table stopping rule that splits data in half, assesses how well each
half does on its own, and compares that to permuted data using a permutation test
without deflation.
The function does not actually compute the p values for each component; that is accomplished by
passing the results to \code{\link[=pval_from_dist]{pval_from_dist()}} or \code{\link[=pvals_all]{pvals_all()}}.
}
